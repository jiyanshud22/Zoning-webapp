<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Floor Zoning Intelligence ‚Äî Scatter Graph &amp; Zone Layout</title>
<!-- FIXED: Load XLSX from CDN instead of local file -->
<!-- Load XLSX from official SheetJS CDN -->
<script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>
<!-- Quick check (optional, remove after confirming) -->
<script>console.log('XLSX loaded?', typeof XLSX);</script><style>
@import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=IBM+Plex+Mono:wght@300;400;500&display=swap');

:root {
  --bg: #f4f1eb;
  --surface: #ffffff;
  --surface2: #ede9e0;
  --border: #d0c9bc;
  --ink: #1a1612;
  --ink2: #5a5248;
  --accent: #c8410e;
  --accent2: #1a5fa8;
  --accent3: #2a8a4a;
  --gold: #d4a017;

  /* Zone colors matching PDF scatter graph legend */
  --focus-open:      #a8d8ea;   /* Light Blue */
  --focus-enclosed:  #1e3a8a;   /* Dark Blue */
  --collab-open:     #fef3c7;   /* Light Yellow */
  --collab-enclosed: #b45309;   /* Dark Yellow */
  --social-open:     #f97316;   /* Dark Orange */
  --support-open:    #e5e7eb;   /* Light Grey */
  --support-enclosed:#4b5563;   /* Dark Grey */
  --circulation:     #fbbf24;   /* Primary Circulation */
  --work:            #3b82f6;   /* Work (ME) */
  --meeting:         #8b5cf6;   /* Meeting (WE) */
  --destination:     #ef4444;   /* Destination/Social Hub */
  --specialty:       #10b981;   /* Specialty */
  --core:            #6b7280;   /* Core */
}

* { margin:0; padding:0; box-sizing:border-box; }

body {
  font-family: 'Space Grotesk', sans-serif;
  background: var(--bg);
  color: var(--ink);
  height: 100vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* ‚îÄ‚îÄ‚îÄ HEADER ‚îÄ‚îÄ‚îÄ */
header {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 10px 20px;
  background: var(--ink);
  color: #fff;
  flex-shrink: 0;
}
.logo {
  font-size: 16px;
  font-weight: 700;
  letter-spacing: -0.5px;
  color: #fff;
}
.logo em { color: var(--accent); font-style: normal; }
.badge {
  background: rgba(255,255,255,0.12);
  border-radius: 4px;
  padding: 3px 10px;
  font-family: 'IBM Plex Mono', monospace;
  font-size: 10px;
  letter-spacing: 1px;
  color: #ccc;
}
.header-stats {
  display: flex; gap: 20px; margin-left: auto;
}
.hstat { text-align: right; }
.hstat-val { font-family: 'IBM Plex Mono', monospace; font-size: 15px; font-weight: 600; color: #a8d8ea; }
.hstat-lbl { font-size: 9px; color: #888; text-transform: uppercase; letter-spacing: 0.5px; }

/* ‚îÄ‚îÄ‚îÄ UPLOAD ‚îÄ‚îÄ‚îÄ */
#upload-screen {
  flex: 1; display: flex; align-items: center; justify-content: center;
  flex-direction: column; gap: 28px;
  background: var(--bg);
}
.upload-title { font-size: 30px; font-weight: 700; text-align: center; line-height: 1.2; }
.upload-title em { color: var(--accent); font-style: normal; }
.upload-sub { font-size: 13px; color: var(--ink2); text-align: center; max-width: 520px; line-height: 1.6; }
.upload-note {
  background: #fff7ed; border: 1px solid #fbbf24; border-radius: 8px;
  padding: 12px 20px; font-size: 12px; color: #92400e; max-width: 560px; line-height: 1.7;
}
.upload-note strong { color: #78350f; }
.upload-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; width: 100%; max-width: 660px; }
.upload-card {
  background: var(--surface); border: 2px dashed var(--border); border-radius: 10px;
  padding: 22px; cursor: pointer; transition: all 0.2s; text-align: center; position: relative;
}
.upload-card:hover { border-color: var(--accent); background: #fff8f6; }
.upload-card.loaded { border-color: var(--accent3); border-style: solid; background: #f0faf4; }
.upload-card input { position: absolute; inset: 0; opacity: 0; cursor: pointer; }
.upload-icon { font-size: 28px; margin-bottom: 8px; }
.upload-card h3 { font-size: 13px; font-weight: 600; margin-bottom: 4px; }
.upload-card p { font-size: 11px; color: var(--ink2); }
.upload-card .fname { margin-top: 8px; font-size: 10px; color: var(--accent3); font-family: 'IBM Plex Mono', monospace; word-break: break-all; }

.process-btn {
  background: var(--accent); color: #fff; border: none; border-radius: 8px;
  padding: 13px 44px; font-family: 'Space Grotesk', sans-serif; font-size: 14px;
  font-weight: 600; cursor: pointer; transition: all 0.2s;
}
.process-btn:hover { background: #b03500; }
.process-btn:disabled { opacity: 0.4; cursor: not-allowed; }

/* ‚îÄ‚îÄ‚îÄ LOADING ‚îÄ‚îÄ‚îÄ */
#loading-screen {
  flex: 1; display: none; align-items: center; justify-content: center; flex-direction: column; gap: 18px;
}
.loading-title { font-size: 18px; font-weight: 600; }
.loading-sub { font-size: 12px; color: var(--ink2); font-family: 'IBM Plex Mono', monospace; }
.progress-bar { width: 360px; height: 4px; background: var(--border); border-radius: 2px; overflow: hidden; }
.progress-fill { height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent2)); width: 0%; transition: width 0.4s ease; }

/* ‚îÄ‚îÄ‚îÄ APP ‚îÄ‚îÄ‚îÄ */
#app-screen { flex: 1; display: none; overflow: hidden; }
.app-layout { display: grid; grid-template-columns: 250px 1fr 300px; height: 100%; }

/* ‚îÄ‚îÄ‚îÄ LEFT SIDEBAR ‚îÄ‚îÄ‚îÄ */
.sidebar-left {
  background: var(--surface); border-right: 1px solid var(--border);
  overflow-y: auto; display: flex; flex-direction: column;
}
.sidebar-section { padding: 12px 14px; border-bottom: 1px solid var(--border); }
.sidebar-section h4 {
  font-size: 9px; text-transform: uppercase; letter-spacing: 1.5px; color: var(--ink2);
  margin-bottom: 9px; font-family: 'IBM Plex Mono', monospace; font-weight: 500;
}
.stat-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 7px; }
.stat-box { background: var(--surface2); border-radius: 6px; padding: 9px; }
.stat-box-val { font-family: 'IBM Plex Mono', monospace; font-size: 16px; font-weight: 600; color: var(--accent); }
.stat-box-lbl { font-size: 9px; color: var(--ink2); margin-top: 2px; }

.filter-group { display: flex; flex-direction: column; gap: 4px; max-height: 160px; overflow-y: auto; }
.filter-chip {
  display: flex; align-items: center; gap: 7px; padding: 5px 8px; border-radius: 5px;
  cursor: pointer; font-size: 11px; border: 1px solid transparent; transition: all 0.12s;
}
.filter-chip:hover { background: var(--surface2); }
.filter-chip.active { background: var(--surface2); border-color: var(--accent); }
.fdot { width: 9px; height: 9px; border-radius: 2px; flex-shrink: 0; }
.fcnt { margin-left: auto; font-family: 'IBM Plex Mono', monospace; font-size: 9px; color: var(--ink2); background: var(--bg); padding: 1px 5px; border-radius: 8px; }

.view-btn {
  background: var(--surface2); border: 1px solid var(--border); border-radius: 6px;
  padding: 6px 10px; font-family: 'Space Grotesk', sans-serif; font-size: 11px;
  color: var(--ink); cursor: pointer; transition: all 0.15s; width: 100%;
  margin-bottom: 5px; font-weight: 500;
}
.view-btn:hover { border-color: var(--accent); color: var(--accent); }
.view-btn.active { background: var(--accent); color: #fff; border-color: var(--accent); }

/* Step Buttons */
.step-btn {
  display: flex; align-items: flex-start; gap: 10px; padding: 9px 10px;
  border: 1px solid var(--border); border-radius: 7px; margin-bottom: 6px;
  cursor: pointer; transition: all 0.15s; background: var(--surface);
}
.step-btn:hover { border-color: var(--accent2); background: #f0f6ff; }
.step-btn.active { border-color: var(--accent2); background: #e8f0fd; }
.step-num {
  width: 20px; height: 20px; border-radius: 50%; background: var(--accent2);
  color: #fff; font-size: 10px; font-weight: 700; display: flex; align-items: center; justify-content: center; flex-shrink: 0;
}
.step-info h5 { font-size: 11px; font-weight: 600; margin-bottom: 2px; }
.step-info p { font-size: 9px; color: var(--ink2); line-height: 1.4; }

/* ‚îÄ‚îÄ‚îÄ MAP ‚îÄ‚îÄ‚îÄ */
.map-container { position: relative; overflow: hidden; background: #f8f6f0; }
#floor-canvas { cursor: grab; display: block; }
#floor-canvas:active { cursor: grabbing; }
.map-controls {
  position: absolute; bottom: 16px; right: 16px; display: flex; flex-direction: column; gap: 5px; z-index: 10;
}
.map-btn {
  width: 32px; height: 32px; background: var(--surface); border: 1px solid var(--border);
  border-radius: 6px; color: var(--ink); font-size: 15px; cursor: pointer;
  display: flex; align-items: center; justify-content: center; transition: all 0.12s;
}
.map-btn:hover { border-color: var(--accent); }

.map-legend {
  position: absolute; bottom: 16px; left: 16px; background: rgba(255,255,255,0.96);
  border: 1px solid var(--border); border-radius: 8px; padding: 12px; z-index: 10; min-width: 170px;
}
.map-legend h5 { font-size: 9px; text-transform: uppercase; letter-spacing: 1px; color: var(--ink2); margin-bottom: 8px; font-family: 'IBM Plex Mono', monospace; }
.legend-item { display: flex; align-items: center; gap: 7px; margin-bottom: 4px; font-size: 10px; }
.lswatch { width: 12px; height: 12px; border-radius: 2px; flex-shrink: 0; border: 1px solid rgba(0,0,0,0.15); }

.step-indicator {
  position: absolute; top: 14px; left: 50%; transform: translateX(-50%);
  background: var(--ink); color: #fff; border-radius: 20px; padding: 5px 16px;
  font-size: 11px; font-weight: 600; z-index: 10; letter-spacing: 0.3px;
  pointer-events: none;
}

/* ‚îÄ‚îÄ‚îÄ RIGHT PANEL ‚îÄ‚îÄ‚îÄ */
.sidebar-right {
  background: var(--surface); border-left: 1px solid var(--border);
  overflow-y: auto; display: flex; flex-direction: column;
}
.panel-header { padding: 12px 14px; border-bottom: 1px solid var(--border); font-weight: 600; font-size: 12px; }
.panel-empty {
  flex: 1; display: flex; align-items: center; justify-content: center; flex-direction: column;
  gap: 10px; color: var(--ink2); font-size: 12px; padding: 20px; text-align: center;
}
.info-block { padding: 12px 14px; border-bottom: 1px solid var(--border); }
.info-block h5 { font-size: 9px; text-transform: uppercase; letter-spacing: 1px; color: var(--ink2); margin-bottom: 7px; font-family: 'IBM Plex Mono', monospace; }
.info-row { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 5px; gap: 8px; }
.info-lbl { color: var(--ink2); flex-shrink: 0; }
.info-val { font-family: 'IBM Plex Mono', monospace; font-size: 10px; text-align: right; word-break: break-word; font-weight: 500; }
.adj-row { margin-bottom: 6px; }
.adj-lbl { display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 3px; color: var(--ink2); }
.adj-bar { height: 5px; background: var(--bg); border-radius: 3px; overflow: hidden; }
.adj-fill { height: 100%; border-radius: 3px; transition: width 0.3s; }
.tag { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: 600; font-family: 'IBM Plex Mono', monospace; }
.tag-ME { background: #dbeafe; color: #1e40af; }
.tag-WE { background: #d1fae5; color: #065f46; }
.tag-US { background: #fef3c7; color: #92400e; }
.tag-Support { background: #f3f4f6; color: #374151; }
.tag-Speciality { background: #ede9fe; color: #5b21b6; }

.bar-row { display: flex; align-items: center; gap: 6px; margin-bottom: 5px; }
.bar-lbl { font-size: 9px; color: var(--ink2); width: 90px; flex-shrink: 0; }
.bar-track { flex: 1; height: 6px; background: var(--bg); border-radius: 3px; overflow: hidden; }
.bar-fill { height: 100%; border-radius: 3px; }
.bar-val { font-family: 'IBM Plex Mono', monospace; font-size: 9px; color: var(--ink2); width: 24px; text-align: right; }

/* Tooltip */
.tooltip {
  position: fixed; background: var(--ink); color: #fff; border-radius: 8px;
  padding: 10px 14px; font-size: 11px; pointer-events: none; z-index: 1000;
  max-width: 220px; box-shadow: 0 6px 24px rgba(0,0,0,0.3); opacity: 0; transition: opacity 0.12s;
}
.tooltip.visible { opacity: 1; }
.tt-name { font-weight: 700; margin-bottom: 4px; font-size: 12px; }
.tt-row { color: #aaa; font-size: 10px; margin-bottom: 2px; }
.tt-row strong { color: #fff; }

/* Step progress bar at top of canvas */
.step-progress {
  position: absolute; top: 0; left: 0; right: 0; height: 3px; z-index: 20;
  display: flex;
}
.sp-seg { flex: 1; margin-right: 1px; background: var(--border); transition: background 0.3s; }
.sp-seg.done { background: var(--accent3); }
.sp-seg.active { background: var(--accent); }

/* Highlight ring for zones */
@keyframes pulse-ring { 0%{opacity:0.8;} 100%{opacity:0.3;} }

/* NH label style (neighbourhood label on zone) */
.nh-tag {
  font-family: 'IBM Plex Mono', monospace;
  font-weight: 700;
}
</style>
</head>
<body>

<header>
  <div class="logo">ZONE<em>INTEL</em> <span style="opacity:0.5;font-size:11px;font-weight:300">v2</span></div>
  <div class="badge" id="floor-badge">AWAITING DATA</div>
  <div class="header-stats" id="header-stats" style="display:none">
    <div class="hstat"><div class="hstat-val" id="hs-zones">‚Äî</div><div class="hstat-lbl">Zones</div></div>
    <div class="hstat"><div class="hstat-val" id="hs-blocks">‚Äî</div><div class="hstat-lbl">Blocks</div></div>
    <div class="hstat"><div class="hstat-val" id="hs-sb">‚Äî</div><div class="hstat-lbl">Superblocks</div></div>
    <div class="hstat"><div class="hstat-val" id="hs-area">‚Äî</div><div class="hstat-lbl">Total m¬≤</div></div>
  </div>
</header>

<!-- UPLOAD -->
<div id="upload-screen">
  <div>
    <div class="upload-title">Floor Zoning Intelligence<br><em>Scatter Graph &amp; Zone Layout Engine</em></div>
    <div class="upload-sub" style="margin-top:10px">
      Upload your spatial JSON (floor plan) and Excel (block data) to run the zoning algorithm.
    </div>
  </div>
  <div class="upload-note">
    <strong>Algorithm:</strong><br>
    <strong>#</strong> ‚Äî Positioning: Scatter blocks on grid by proximity &amp; adjacency rules<br>
    <strong>#</strong> ‚Äî Zone Splitting: Split into sub-zones by superblock, area &amp; block count<br>
    <strong>#</strong> ‚Äî Geometric Sizing: Define X/Y dimensions, aspect ratios, fit to grid<br>
    <strong>#</strong> ‚Äî Zone Boundary Definition: Label zones with area and block metadata
  </div>
  <div class="upload-grid">
    <div class="upload-card" id="json-card">
      <input type="file" id="json-input" accept=".json">
      <div class="upload-icon">üó∫Ô∏è</div>
      <h3>Spatial Data (JSON)</h3>
      <p>Floor plan with polygons, walls, columns, boundaries</p>
      <div class="fname" id="json-fname">Drop or click to upload</div>
    </div>
    <div class="upload-card" id="excel-card">
      <input type="file" id="excel-input" accept=".xlsx,.xls">
      <div class="upload-icon">üìä</div>
      <h3>Zoning Data (Excel)</h3>
      <p>Block data, adjacency matrices, superblocks, priorities</p>
      <div class="fname" id="excel-fname">Drop or click to upload</div>
    </div>
  </div>
  <button class="process-btn" id="process-btn" disabled="" onclick="processFiles()">
    ‚ö° Run Zoning Algorithm
  </button>
</div>

<!-- LOADING -->
<div id="loading-screen">
  <div class="loading-title" id="loading-title">Running Zoning Algorithm‚Ä¶</div>
  <div class="loading-sub" id="loading-sub">Initializing‚Ä¶</div>
  <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
</div>

<!-- APP -->
<div id="app-screen">
  <div class="app-layout">

    <!-- LEFT -->
    <div class="sidebar-left">
      <div class="sidebar-section">
        <h4>Statistics</h4>
        <div class="stat-grid">
          <div class="stat-box"><div class="stat-box-val" id="s-total">0</div><div class="stat-box-lbl">Total Zones</div></div>
          <div class="stat-box"><div class="stat-box-val" id="s-matched">0</div><div class="stat-box-lbl">Matched</div></div>
          <div class="stat-box"><div class="stat-box-val" id="s-sb">0</div><div class="stat-box-lbl">Superblocks</div></div>
          <div class="stat-box"><div class="stat-box-val" id="s-area">0</div><div class="stat-box-lbl">Total m¬≤</div></div>
        </div>
      </div>

      <div class="sidebar-section">
        <h4>Algorithm Steps</h4>
        <div id="step-buttons"></div>
      </div>

      <div class="sidebar-section">
        <h4>Color Mode</h4>
        <div id="color-modes"></div>
      </div>

      <div class="sidebar-section">
        <h4>SpaceMix Filter</h4>
        <div class="filter-group" id="spacemix-filters"></div>
      </div>

      <div class="sidebar-section">
        <h4>Block Type Filter</h4>
        <div class="filter-group" id="blocktype-filters"></div>
      </div>

      <div class="sidebar-section" style="margin-top:auto">
        <div style="display:flex;gap:6px">
          <button class="view-btn" onclick="fitView()">‚ä° Fit</button>
          <button class="view-btn" onclick="resetFilters()">‚Ü∫ Reset</button>
        </div>
      </div>
    </div>

    <!-- MAP -->
    <div class="map-container" id="map-container">
      <div class="step-progress" id="step-progress">
        <div class="sp-seg active" id="sp1"></div>
        <div class="sp-seg" id="sp2"></div>
        <div class="sp-seg" id="sp3"></div>
        <div class="sp-seg" id="sp4"></div>
      </div>
      <div class="step-indicator" id="step-indicator">Step 1 ‚Äî Scatter Graph</div>
      <canvas id="floor-canvas"></canvas>
      <div class="map-controls">
        <button class="map-btn" onclick="zoom(1.25)" title="Zoom In">+</button>
        <button class="map-btn" onclick="zoom(0.8)" title="Zoom Out">‚àí</button>
        <button class="map-btn" onclick="fitView()" title="Fit">‚ä°</button>
      </div>
      <div class="map-legend" id="map-legend"></div>
    </div>

    <!-- RIGHT -->
    <div class="sidebar-right">
      <div class="panel-header">Zone Details</div>
      <div id="panel-empty" class="panel-empty">
        <span style="font-size:28px">üó∫Ô∏è</span>
        <div>Hover over a zone to inspect block data</div>
        <div style="font-size:10px;color:var(--ink2);margin-top:4px">Click to pin selection</div>
      </div>
      <div id="panel-content" style="display:none"></div>
      <div class="info-block" id="analysis-block" style="margin-top:auto"></div>
    </div>

  </div>
</div>

<!-- TOOLTIP -->
<div class="tooltip" id="tooltip">
  <div class="tt-name" id="tt-name"></div>
  <div class="tt-row" id="tt-1"></div>
  <div class="tt-row" id="tt-2"></div>
  <div class="tt-row" id="tt-3"></div>
</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  GLOBAL STATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let appData = null;
let canvas, ctx;
let camX = 0, camY = 0, camScale = 1;
let dragging = false, lastMX = 0, lastMY = 0;
let hoveredZone = null, pinnedZone = null;
let jsonFile = null, excelFile = null;
let currentStep = 1;        // 1=scatter, 2=split, 3=sizing, 4=boundary
let colorMode = 'scatter';  // scatter / blocktype / spacemix / superblock / placement
let activeFilters = { spacemix: new Set(), blocktype: new Set() };

// PDF color map ‚Äî matching the manual scatter graph legend from the document
const ZONE_COLORS_SCATTER = {
  'ME':          '#4a90e2',   // Focus Open ‚Äî Light Blue
  'WE':          '#1e3a8a',   // Collab Enclosed ‚Äî Dark Blue
  'Support':     '#9ca3af',   // Support Open ‚Äî Light Grey
  'Speciality':  '#f97316',   // Social/Destination ‚Äî Orange
  'US':          '#fbbf24',   // Circulation ‚Äî Gold
  'Unknown':     '#d1d5db',
};

const SPACEMIX_COLORS = {
  'ME': '#4a90e2', 'WE': '#1e3a8a', 'Support': '#9ca3af',
  'Speciality': '#f97316', 'US': '#fbbf24', 'Unknown': '#d1d5db'
};

const SUPERBLOCK_PALETTE = [
  '#e85d4a','#4a90e2','#f59e0b','#10b981','#8b5cf6',
  '#ef4444','#06b6d4','#84cc16','#f97316','#ec4899',
  '#6366f1','#14b8a6','#eab308','#a855f7','#22c55e',
];

const BLOCKTYPE_COLORS = {
  'Work Zone': '#3b82f6',
  'Meeting Zone - Rooms/ Spaces': '#8b5cf6',
  'Support - Workplace Storage': '#d97706',
  'Support - Workplace Support': '#f59e0b',
  'Social Hub': '#ef4444',
  'Destination': '#dc2626',
  '': '#9ca3af',
};

// PLACEMENT colors matching PDF zoning layout (Step 4)
const PLACEMENT_COLORS = {
  'Destination': '#dc2626',
  'Social Hub': '#f97316',
  'Meeting': '#8b5cf6',
  'Work': '#3b82f6',
  'Think': '#06b6d4',
  'Collab': '#fbbf24',
  'Support - Speciality': '#6b7280',
  'Support': '#9ca3af',
  'Circulation': '#d4a017',
  'Core': '#374151',
  'Community Zone': '#ef4444',
  'Other': '#d1d5db',
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  FILE UPLOAD
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
document.getElementById('json-input').onchange = e => {
  jsonFile = e.target.files[0];
  document.getElementById('json-fname').textContent = jsonFile.name;
  document.getElementById('json-card').classList.add('loaded');
  checkReady();
};
document.getElementById('excel-input').onchange = e => {
  excelFile = e.target.files[0];
  document.getElementById('excel-fname').textContent = excelFile.name;
  document.getElementById('excel-card').classList.add('loaded');
  checkReady();
};
function checkReady() {
  document.getElementById('process-btn').disabled = !(jsonFile && excelFile);
}
['json-card','excel-card'].forEach(id => {
  const card = document.getElementById(id);
  card.addEventListener('dragover', e => { e.preventDefault(); card.classList.add('drag-over'); });
  card.addEventListener('dragleave', () => card.classList.remove('drag-over'));
  card.addEventListener('drop', e => {
    e.preventDefault(); card.classList.remove('drag-over');
    const file = e.dataTransfer.files[0]; if (!file) return;
    if (id === 'json-card') { jsonFile = file; document.getElementById('json-fname').textContent = file.name; card.classList.add('loaded'); }
    else { excelFile = file; document.getElementById('excel-fname').textContent = file.name; card.classList.add('loaded'); }
    checkReady();
  });
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  PROCESS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function processFiles() {
  showLoading();
  setProgress(5, 'Reading JSON floor plan‚Ä¶');
  await sleep(80);
  try {
    const jsonText = await readFile(jsonFile, 'text');
    const jsonData = JSON.parse(jsonText);
    setProgress(20, 'Parsing spatial entities‚Ä¶');
    await sleep(80);

    const excelBuffer = await readFile(excelFile, 'arraybuffer');
    setProgress(35, 'Reading Excel sheets‚Ä¶');
    await sleep(80);

    const wb = XLSX.read(excelBuffer, { type: 'array' });
    setProgress(50, 'Processing block data & adjacency‚Ä¶');
    await sleep(80);

    const processed = await processData(jsonData, wb);
    setProgress(75, 'Step 1 ‚Äî Building scatter graph‚Ä¶');
    await sleep(100);

    appData = processed;
    runZoningAlgorithm();
    setProgress(95, 'Rendering floor plan‚Ä¶');
    await sleep(80);

    launchApp();
    setProgress(100, 'Complete!');
    await sleep(300);
  } catch (err) {
    alert('Error: ' + err.message + '\n' + err.stack);
    console.error(err);
    showUpload();
  }
}

function readFile(file, mode) {
  return new Promise((res, rej) => {
    const r = new FileReader();
    r.onload = e => res(e.target.result);
    r.onerror = rej;
    mode === 'text' ? r.readAsText(file) : r.readAsArrayBuffer(file);
  });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  DATA PROCESSING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function processData(jsonData, wb) {
  const entities = jsonData.entities || [];

  // Spatial zones (area polygons)
  const zonePolygons = [];
  for (const e of entities) {
    if (e.type !== 'AreaPolygon') continue;
    const d = e.data;
    // Accept all area polygon layers that could be zoning
    const pts = d.polygon || [];
    if (!pts.length) continue;
    const name = (d.name || '').trim();
    const cx = pts.reduce((s,p) => s+p.x, 0)/pts.length;
    const cy = pts.reduce((s,p) => s+p.y, 0)/pts.length;
    zonePolygons.push({
      uid: d.uid || Math.random().toString(36).slice(2),
      spatial_name: name,
      layer: d.layer || '',
      points: pts,
      fill_color: d.style?.fillColor,
      centroid_x: cx,
      centroid_y: cy,
      bbox: { minX: Math.min(...pts.map(p=>p.x)), maxX: Math.max(...pts.map(p=>p.x)),
               minY: Math.min(...pts.map(p=>p.y)), maxY: Math.max(...pts.map(p=>p.y)) },
      spatial_area_m2: Math.abs(polygonArea(pts)) / 1e6,
    });
  }

  // Walls, columns, boundaries
  const walls = entities.filter(e=>e.type==='Wall').map(e=>({
    x1:e.data.cl?.x||0, y1:e.data.cl?.y||0, x2:e.data.cr?.x||0, y2:e.data.cr?.y||0,
  }));
  const columns = entities.filter(e=>e.type==='SMColumn').map(e=>({ points: e.data.polygon||[] }));
  const roomBoundaries = [];
  for (const e of entities) {
    if (e.type !== 'Boundary') continue;
    const d = e.data;
    const sp = d.serializedPath;
    if (!sp) continue;
    const pts = sp.shape?.points || sp.area?.points || [];
    if (!pts.length) continue;
    roomBoundaries.push({ uid: d.uid, room_name: (d.name||'').trim(), points: pts,
      centroid_x: pts.reduce((s,p)=>s+p.x,0)/pts.length,
      centroid_y: pts.reduce((s,p)=>s+p.y,0)/pts.length });
  }

  // Excel parsing
  const blocks = parseBlockData(wb);
  const bfeat = parseBuildingFeatureAdj(wb);
  const [btbMin, btbMax] = parseBTBAdj(wb);
  const ncAdj = parseNCAdj(wb);
  const priorities = parsePriorities(wb);

  // Match zones to blocks
  const zones = matchZones(zonePolygons, blocks, bfeat, btbMin, btbMax);

  const allX = zones.flatMap(z=>z.points.map(p=>p.x));
  const allY = zones.flatMap(z=>z.points.map(p=>p.y));
  const floorBounds = {
    minX: Math.min(...allX), maxX: Math.max(...allX),
    minY: Math.min(...allY), maxY: Math.max(...allY),
  };

  return { zones, roomBoundaries, walls, columns, floorBounds, blocks, bfeat, btbMin, btbMax, ncAdj, priorities };
}

function parseBlockData(wb) {
  // Try multiple sheet name variants
  const sheetNames = ['Level 4 - Block Data', 'Block Data', 'Blocks', wb.SheetNames.find(n=>n.toLowerCase().includes('block'))].filter(Boolean);
  let sheet = null;
  for (const sn of sheetNames) { if (wb.Sheets[sn]) { sheet = wb.Sheets[sn]; break; } }
  if (!sheet) {
    // Use first sheet as fallback
    sheet = wb.Sheets[wb.SheetNames[0]];
  }
  if (!sheet) return [];
  const rows = XLSX.utils.sheet_to_json(sheet, { defval: '' });
  return rows.filter(r => r.Block_ID || r.block_id || r['Block ID']).map(r => ({
    block_id: r.Block_ID || r.block_id || r['Block ID'],
    block_name: String(r.Block_Name || r.block_name || r['Block Name'] || '').trim(),
    block_instance: String(r.Block_Instance_Name || r['Block Instance Name'] || '').trim(),
    superblock: String(r['pre-processed placement-bundles_Logic 1'] || r.Superblock || r['Super Block'] || '').trim(),
    spacemix: String(r['SpaceMix_(ME_WE_US_Support_Speciality)'] || r.SpaceMix || r['Space Mix'] || '').trim(),
    block_type: String(r.Block_Type || r['Block Type'] || '').trim(),
    department: String(r.Department_Sub_Department || r.Department || '').trim(),
    open_closed: String(r['Open/Closed'] || r.OpenClosed || '').trim(),
    capacity: parseFloat(r.Block_Capacity || r['Block Capacity']) || null,
    area: parseFloat(r.Block_Area || r['Block Area']) || null,
    // Placement category derived from block type/spacemix
    placement_cat: derivePlacementCat(r),
  }));
}

function derivePlacementCat(r) {
  const bt = String(r.Block_Type || r['Block Type'] || '').toLowerCase();
  const sm = String(r['SpaceMix_(ME_WE_US_Support_Speciality)'] || r.SpaceMix || '').toLowerCase();
  const nm = String(r.Block_Name || r['Block Name'] || '').toLowerCase();
  if (nm.includes('social') || nm.includes('hub') || nm.includes('lounge')) return 'Social Hub';
  if (nm.includes('reception') || nm.includes('destination') || nm.includes('arrival')) return 'Destination';
  if (nm.includes('meeting') || nm.includes('boardroom') || nm.includes('conference')) return 'Meeting';
  if (nm.includes('collab') || nm.includes('team') || nm.includes('workshop')) return 'Collab';
  if (nm.includes('focus') || nm.includes('quiet') || nm.includes('think') || nm.includes('phone')) return 'Think';
  if (nm.includes('work') || nm.includes('desk') || nm.includes('seat') || nm.includes('touchdown')) return 'Work';
  if (nm.includes('support') || nm.includes('storage') || nm.includes('locker') || nm.includes('copy') || nm.includes('print')) return 'Support';
  if (nm.includes('speciality') || nm.includes('specialty') || nm.includes('wellness')) return 'Support - Speciality';
  if (sm === 'we') return 'Meeting';
  if (sm === 'me') return 'Work';
  if (sm === 'support') return 'Support';
  if (sm === 'speciality') return 'Support - Speciality';
  return 'Other';
}

function parseBuildingFeatureAdj(wb) {
  const sheet = wb.Sheets['Block to Building Feature Adjac'] || wb.Sheets[wb.SheetNames.find(n=>n.toLowerCase().includes('building feature'))] ;
  if (!sheet) return {};
  const rows = XLSX.utils.sheet_to_json(sheet, { defval: 0 });
  const result = {};
  for (const r of rows) {
    const bn = String(r.Block_Name || r['Block Name'] || '').trim();
    if (bn) result[bn] = {
      AHU: parseFloat(r.AHU)||0,
      Window: parseFloat(r['Window/Glazing Wall/Periferral Glazing']||r.Window)||0,
      Main_Entry: parseFloat(r['Main Entry'])||0,
      Toilets: parseFloat(r.Toilets)||0,
      Service_Entry: parseFloat(r['Service Entry'])||0,
      Fire_Egress: parseFloat(r['Fire Egress/Fire exit']||r['Fire Egress'])||0,
      Terrace: parseFloat(r['Terrace/ Balcony']||r.Terrace)||0,
      Core: parseFloat(r.Core)||0,
    };
  }
  return result;
}

function parseBTBAdj(wb) {
  const parse = (sheetName) => {
    const sheet = wb.Sheets[sheetName] || wb.Sheets[wb.SheetNames.find(n=>n.toLowerCase().includes(sheetName.toLowerCase().slice(0,10)))];
    if (!sheet) return {};
    const rows = XLSX.utils.sheet_to_json(sheet, { defval: 0, header: 1 });
    const result = {};
    if (rows.length < 2) return result;
    const header = rows[0];
    const descEnd = 6;
    const targets = header.slice(descEnd).map(v => String(v||'').trim()).filter(Boolean);
    for (const row of rows.slice(1)) {
      const src = String(row[1]||'').trim();
      if (!src) continue;
      result[src] = result[src] || {};
      targets.forEach((t, i) => { const v = parseFloat(row[descEnd+i]); if (!isNaN(v)) result[src][t] = v; });
    }
    return result;
  };
  return [parse('Block to Block Adjacency - Min '), parse('Block to Block Adjacency - Max ')];
}

function parseNCAdj(wb) {
  const sheet = wb.Sheets['Non-Comprimisable Adjacency'] || wb.Sheets[wb.SheetNames.find(n=>n.toLowerCase().includes('non-comp'))];
  if (!sheet) return [];
  const rows = XLSX.utils.sheet_to_json(sheet, { defval: '', header: 1 });
  return rows.slice(1).filter(r=>r[0]||r[1]).map(r=>({ category: String(r[0]||'').trim(), requirement: String(r[1]||'').trim() }));
}

function parsePriorities(wb) {
  const sheet = wb.Sheets['Priority Logic'] || wb.Sheets[wb.SheetNames.find(n=>n.toLowerCase().includes('priority'))];
  if (!sheet) return [];
  const rows = XLSX.utils.sheet_to_json(sheet, { defval: '' });
  return rows.filter(r=>r.Priority).map(r=>({ priority: String(r.Priority).trim(), rule: String(r['Rule/Logic Order']||r.Rule||'').trim() }));
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  ZONE MATCHING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function normName(s) { return s.toLowerCase().replace(/[-\s_]+\d+\s*$/, '').replace(/\s+/,' ').trim(); }

function nameSim(a, b) {
  const ta = new Set(normName(a).split(' ').filter(w=>w.length>2));
  const tb = new Set(normName(b).split(' ').filter(w=>w.length>2));
  const inter = [...ta].filter(x=>tb.has(x)).length;
  const union = new Set([...ta, ...tb]).size;
  return union ? inter/union : 0;
}

function matchZones(zones, blocks, bfeat, btbMin, btbMax) {
  const byName = {};
  for (const b of blocks) {
    if (!byName[b.block_name]) byName[b.block_name] = [];
    byName[b.block_name].push(b);
  }
  return zones.map(zp => {
    const sn = zp.spatial_name;
    let best = null, bestScore = 0;
    for (const [bn, rows] of Object.entries(byName)) {
      let sim = nameSim(sn, bn);
      const na = normName(bn), nb = normName(sn);
      if (na && nb && (na.includes(nb) || nb.includes(na))) sim = Math.max(sim, 0.8);
      if (sim >= 0.25 && sim > bestScore) { bestScore = sim; best = rows[0]; }
    }
    return {
      ...zp,
      block_name: best?.block_name || sn || 'Unknown',
      block_id: best?.block_id || null,
      block_instance: best?.block_instance || '',
      superblock: best?.superblock || 'Unassigned',
      spacemix: best?.spacemix || 'Unknown',
      block_type: best?.block_type || '',
      department: best?.department || '',
      open_closed: best?.open_closed || '',
      block_capacity: best?.capacity,
      block_area_m2: best?.area,
      match_score: bestScore,
      placement_cat: best?.placement_cat || derivePlacementCatFromName(sn),
      building_features: bfeat[best?.block_name] || {},
      btb_min: btbMin[best?.block_name] || {},
      btb_max: btbMax[best?.block_name] || {},
    };
  });
}

function derivePlacementCatFromName(name) {
  const n = (name||'').toLowerCase();
  if (n.includes('social') || n.includes('hub') || n.includes('lounge')) return 'Social Hub';
  if (n.includes('reception') || n.includes('destination')) return 'Destination';
  if (n.includes('meeting') || n.includes('board') || n.includes('conf')) return 'Meeting';
  if (n.includes('collab') || n.includes('team')) return 'Collab';
  if (n.includes('focus') || n.includes('quiet') || n.includes('think') || n.includes('phone')) return 'Think';
  if (n.includes('work') || n.includes('desk') || n.includes('seat')) return 'Work';
  if (n.includes('support') || n.includes('storage') || n.includes('locker')) return 'Support';
  if (n.includes('core') || n.includes('lift') || n.includes('stair')) return 'Core';
  return 'Other';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  ZONING ALGORITHM ‚Äî 4 STEPS FROM PDF
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function runZoningAlgorithm() {
  const zones = appData.zones;

  // ‚îÄ‚îÄ STEP 1: Scatter Graph ‚Äî Positioning ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Assign position scores based on proximity to building features
  // Rules from PDF: Destination ‚Üí near core entry, ME blocks near periphery,
  // WE near core, Support near core/internal, Social Hub at prominent positions

  const { floorBounds: fb } = appData;
  const floorCx = (fb.minX + fb.maxX) / 2;
  const floorCy = (fb.minY + fb.maxY) / 2;
  const floorW = fb.maxX - fb.minX;
  const floorH = fb.maxY - fb.minY;

  for (const z of zones) {
    const bf = z.building_features || {};
    // Distance to center (normalized 0=center, 1=edge)
    const dx = (z.centroid_x - floorCx) / (floorW/2);
    const dy = (z.centroid_y - floorCy) / (floorH/2);
    const distToCenter = Math.min(1, Math.sqrt(dx*dx + dy*dy));
    const distToPeriphery = 1 - distToCenter;

    // Scatter positioning score: how well the zone is positioned
    // based on its building feature adjacency requirements
    let positionScore = 0;
    const windowPref = bf.Window || 0;
    const corePref = bf.Core || 0;
    const entryPref = bf.Main_Entry || 0;

    // Window preference: score better if on periphery (far from center)
    if (windowPref > 0) positionScore += windowPref * distToPeriphery;
    else if (windowPref === -1) positionScore -= distToPeriphery; // penalize if near window

    // Core preference: score better if near center
    if (corePref > 0) positionScore += corePref * distToCenter;

    // Entry preference: score well if near entry (bottom of floorplan typically)
    if (entryPref > 0) {
      const entryDist = 1 - Math.abs(dy - 0.3); // Assume entry near bottom
      positionScore += entryPref * entryDist;
    }

    z.position_score = positionScore;
    z.dist_to_center = distToCenter;
    z.dist_to_periphery = distToPeriphery;

    // Determine ideal PLACEMENT ZONE from PDF logic
    // Step 1 order: Destination ‚Üí Social Hub ‚Üí Typical ME ‚Üí Typical WE ‚Üí Support ‚Üí Specialty
    const sm = (z.spacemix || '').toUpperCase();
    const pc = z.placement_cat || '';
    z.zone_category = pc || (sm === 'ME' ? 'Work' : sm === 'WE' ? 'Meeting' : sm === 'US' ? 'Destination' : 'Support');
  }

  // ‚îÄ‚îÄ STEP 2: Zone Splitting Logic ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Group zones by superblock, then assign split-zone IDs
  // Each superblock becomes a "split zone" with block count and area
  const superblockGroups = {};
  for (const z of zones) {
    const sb = z.superblock || 'Unassigned';
    if (!superblockGroups[sb]) superblockGroups[sb] = [];
    superblockGroups[sb].push(z);
  }

  const sbKeys = Object.keys(superblockGroups).sort((a,b) => {
    // Sort by placement priority: Destination > Social > ME > WE > Support
    const priority = { 'Destination':0, 'Social Hub':1, 'Community Zone':2, 'Work':3, 'Think':3, 'Meeting':4, 'Collab':4, 'Support - Speciality':5, 'Support':6, 'Other':7 };
    const pa = Math.min(...superblockGroups[a].map(z=>priority[z.zone_category]||7));
    const pb = Math.min(...superblockGroups[b].map(z=>priority[z.zone_category]||7));
    return pa - pb;
  });

  sbKeys.forEach((sb, idx) => {
    const group = superblockGroups[sb];
    const totalArea = group.reduce((s,z) => s+(z.spatial_area_m2||0), 0);
    const blockCount = group.length;
    group.forEach(z => {
      z.split_zone_id = sb === 'Unassigned' ? null : `SB${String(idx+1).padStart(2,'0')}`;
      z.split_zone_label = sb;
      z.split_block_count = blockCount;
      z.split_area = totalArea;
      z.split_zone_color_idx = idx;
    });
  });

  // ‚îÄ‚îÄ STEP 3: Geometric Sizing Logic ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // For each zone: compute X/Y aspect ratio, min/max dimension,
  // whether it fits as S/M/L (Function/Comfort/Luxury)
  for (const z of zones) {
    const w = z.bbox.maxX - z.bbox.minX;
    const h = z.bbox.maxY - z.bbox.minY;
    const aspectRatio = w > 0 && h > 0 ? w/h : 1;
    const area = z.spatial_area_m2 || 0;

    // S/M/L classification per PDF
    let sizeClass = 'S';
    if (area > 20) sizeClass = 'M';
    if (area > 50) sizeClass = 'L';

    // Fit quality: how well the zone's actual geometry matches the block requirements
    const expectedArea = z.block_area_m2 || area;
    const areaMatch = expectedArea > 0 ? Math.min(area, expectedArea)/Math.max(area, expectedArea) : 1;

    // Aspect ratio preference: enclosed blocks prefer more square shapes
    const isEnclosed = (z.open_closed || '').toLowerCase() === 'enclosed';
    const idealAR = isEnclosed ? 1.2 : 2.5;
    const arScore = 1 - Math.min(1, Math.abs(aspectRatio - idealAR)/idealAR);

    z.geom_width = w;
    z.geom_height = h;
    z.aspect_ratio = aspectRatio;
    z.size_class = sizeClass;
    z.geom_fit_score = (areaMatch + arScore) / 2;
    z.is_enclosed = isEnclosed;
  }

  // ‚îÄ‚îÄ STEP 4: Zone Boundary Definition ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Assign final zone boundary labels and compute aggregate stats
  const zoneCategories = {};
  for (const z of zones) {
    const cat = z.zone_category || 'Other';
    if (!zoneCategories[cat]) zoneCategories[cat] = { zones:[], totalArea:0, blockCount:0 };
    zoneCategories[cat].zones.push(z);
    zoneCategories[cat].totalArea += z.spatial_area_m2||0;
    zoneCategories[cat].blockCount++;
    z.zone_boundary_label = `${cat} Zone`;
  }

  // Store analysis
  const spacemix = {}, blocktype = {}, superblocks = {};
  let totalArea = 0, matched = 0;
  for (const z of zones) {
    const sm = z.spacemix||'Unknown'; spacemix[sm] = (spacemix[sm]||0)+1;
    const bt = z.block_type||'Unknown'; blocktype[bt] = (blocktype[bt]||0)+1;
    const sb = z.superblock||'Unassigned'; superblocks[sb] = (superblocks[sb]||0)+1;
    totalArea += z.spatial_area_m2||0;
    if (z.match_score > 0) matched++;
  }

  appData.analysis = { spacemix, blocktype, superblocks, zoneCategories, totalArea: Math.round(totalArea), matched, total: zones.length };
  appData.superblockGroups = superblockGroups;
}

function polygonArea(pts) {
  let area = 0;
  for (let i=0; i<pts.length; i++) {
    const j = (i+1)%pts.length;
    area += pts[i].x*pts[j].y - pts[j].x*pts[i].y;
  }
  return Math.abs(area)/2;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  SCREEN TRANSITIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function showLoading() {
  document.getElementById('upload-screen').style.display = 'none';
  document.getElementById('loading-screen').style.display = 'flex';
  document.getElementById('app-screen').style.display = 'none';
}
function showUpload() {
  document.getElementById('upload-screen').style.display = 'flex';
  document.getElementById('loading-screen').style.display = 'none';
  document.getElementById('app-screen').style.display = 'none';
}
function setProgress(pct, msg) {
  document.getElementById('progress-fill').style.width = pct+'%';
  if (msg) document.getElementById('loading-sub').textContent = msg;
}
function sleep(ms) { return new Promise(r=>setTimeout(r,ms)); }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  LAUNCH
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function launchApp() {
  document.getElementById('loading-screen').style.display = 'none';
  document.getElementById('app-screen').style.display = 'block';
  canvas = document.getElementById('floor-canvas');
  ctx = canvas.getContext('2d');
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  buildSidebar();
  updateHeaderStats();
  buildAnalysisPanel();
  fitView();
  setupMouseEvents();
  setCurrentStep(1);
  requestAnimationFrame(renderLoop);
}

function resizeCanvas() {
  const c = document.getElementById('map-container');
  canvas.width = c.clientWidth;
  canvas.height = c.clientHeight;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  STEP MANAGEMENT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const STEP_LABELS = [
  { n:1, label:'Step 1 ‚Äî Scatter Graph', sub:'Positioning by proximity & adjacency rules' },
  { n:2, label:'Step 2 ‚Äî Zone Splitting', sub:'Superblock grouping with block count & area' },
  { n:3, label:'Step 3 ‚Äî Geometric Sizing', sub:'X/Y dimensions, aspect ratio, S/M/L fit' },
  { n:4, label:'Step 4 ‚Äî Zone Boundaries', sub:'Final zone labels and area definition' },
];

function buildSidebar() {
  // Step buttons
  const sb = document.getElementById('step-buttons');
  sb.innerHTML = STEP_LABELS.map(s => `
    <div class="step-btn ${currentStep===s.n?'active':''}" id="stepbtn-${s.n}" onclick="setCurrentStep(${s.n})">
      <div class="step-num">${s.n}</div>
      <div class="step-info"><h5>${s.label.replace('Step '+s.n+' ‚Äî ','')}</h5><p>${s.sub}</p></div>
    </div>
  `).join('');

  // Color modes
  const cm = document.getElementById('color-modes');
  const modes = [
    { id:'scatter', label:'Scatter (SpaceMix)' },
    { id:'placement', label:'Placement Zone' },
    { id:'superblock', label:'Superblock' },
    { id:'blocktype', label:'Block Type' },
    { id:'sizing', label:'Geometric Fit' },
  ];
  cm.innerHTML = modes.map(m => `<button class="view-btn ${colorMode===m.id?'active':''}" id="cm-${m.id}" onclick="setColorMode('${m.id}')">${m.label}</button>`).join('');

  // SpaceMix filters
  const sm = appData.analysis.spacemix;
  document.getElementById('spacemix-filters').innerHTML = Object.entries(sm).sort((a,b)=>b[1]-a[1]).map(([k,v])=>`
    <div class="filter-chip" onclick="toggleFilter('spacemix','${k}',this)">
      <div class="fdot" style="background:${SPACEMIX_COLORS[k]||'#ccc'}"></div>
      ${k} <span class="fcnt">${v}</span>
    </div>`).join('');

  const bt = appData.analysis.blocktype;
  document.getElementById('blocktype-filters').innerHTML = Object.entries(bt).sort((a,b)=>b[1]-a[1]).slice(0,10).map(([k,v])=>`
    <div class="filter-chip" onclick="toggleFilter('blocktype','${k}',this)">
      <div class="fdot" style="background:${BLOCKTYPE_COLORS[k]||'#ccc'}"></div>
      <span title="${k}">${k.length>22?k.slice(0,20)+'‚Ä¶':k}</span> <span class="fcnt">${v}</span>
    </div>`).join('');

  buildLegend();
}

function setCurrentStep(n) {
  currentStep = n;
  // Update step buttons
  STEP_LABELS.forEach(s => {
    const el = document.getElementById('stepbtn-'+s.n);
    if (el) el.classList.toggle('active', s.n === n);
  });
  // Update progress segments
  for (let i=1;i<=4;i++) {
    const seg = document.getElementById('sp'+i);
    if (seg) { seg.classList.toggle('done', i<n); seg.classList.toggle('active', i===n); }
  }
  // Update step indicator
  const lbl = STEP_LABELS.find(s=>s.n===n);
  document.getElementById('step-indicator').textContent = lbl ? lbl.label : '';
}

function setColorMode(mode) {
  colorMode = mode;
  document.querySelectorAll('[id^=cm-]').forEach(el => {
    el.classList.toggle('active', el.id === 'cm-'+mode);
  });
  buildLegend();
}

function buildLegend() {
  const leg = document.getElementById('map-legend');
  let items = [];
  if (colorMode === 'scatter' || colorMode === 'superblock') {
    items = Object.entries(SPACEMIX_COLORS).map(([k,c]) => ({ label:k, color:c }));
    if (colorMode === 'superblock' && appData) {
      const sbs = Object.keys(appData.analysis.superblocks).slice(0,8);
      items = sbs.map((sb,i) => ({ label:sb.length>20?sb.slice(0,18)+'‚Ä¶':sb, color:SUPERBLOCK_PALETTE[i%SUPERBLOCK_PALETTE.length] }));
    }
  } else if (colorMode === 'placement') {
    items = Object.entries(PLACEMENT_COLORS).map(([k,c]) => ({ label:k, color:c }));
  } else if (colorMode === 'blocktype') {
    items = Object.entries(BLOCKTYPE_COLORS).filter(([k])=>k).map(([k,c]) => ({ label:k.replace(/Support - /,'').replace(/ - Rooms\/ Spaces/,''), color:c }));
  } else if (colorMode === 'sizing') {
    items = [
      { label:'Excellent fit (>80%)', color:'#10b981' },
      { label:'Good fit (60-80%)', color:'#f59e0b' },
      { label:'Poor fit (<60%)', color:'#ef4444' },
    ];
  }
  leg.innerHTML = `<h5>${colorMode === 'scatter' ? 'SpaceMix / Scatter' : colorMode === 'superblock' ? 'Superblocks' : colorMode === 'placement' ? 'Placement Zone' : colorMode === 'sizing' ? 'Geometric Fit' : 'Block Type'}</h5>` +
    items.map(it => `<div class="legend-item"><div class="lswatch" style="background:${it.color}"></div>${it.label}</div>`).join('');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  COLOR RESOLUTION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function getZoneColor(zone, alpha=0.72) {
  let hex = '#9ca3af';
  if (colorMode === 'scatter') {
    hex = SPACEMIX_COLORS[zone.spacemix] || '#d1d5db';
  } else if (colorMode === 'placement') {
    hex = PLACEMENT_COLORS[zone.placement_cat] || PLACEMENT_COLORS[zone.zone_category] || '#d1d5db';
  } else if (colorMode === 'superblock') {
    const idx = zone.split_zone_color_idx || 0;
    hex = SUPERBLOCK_PALETTE[idx % SUPERBLOCK_PALETTE.length];
  } else if (colorMode === 'blocktype') {
    hex = BLOCKTYPE_COLORS[zone.block_type] || '#9ca3af';
  } else if (colorMode === 'sizing') {
    const score = zone.geom_fit_score || 0;
    if (score >= 0.8) hex = '#10b981';
    else if (score >= 0.6) hex = '#f59e0b';
    else hex = '#ef4444';
  }
  return hexToRgba(hex, alpha);
}

function hexToRgba(hex, alpha) {
  if (!hex || hex.length < 7) return `rgba(150,150,150,${alpha})`;
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  return `rgba(${r},${g},${b},${alpha})`;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CANVAS RENDERING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function worldToScreen(x,y) {
  return [(x-camX)*camScale+canvas.width/2, (y-camY)*camScale+canvas.height/2];
}

function fitView() {
  if (!appData) return;
  const b = appData.floorBounds;
  const W = canvas.width-60, H = canvas.height-60;
  const fw = b.maxX-b.minX, fh = b.maxY-b.minY;
  if (fw===0||fh===0) return;
  camScale = Math.min(W/fw, H/fh)*0.88;
  camX = (b.minX+b.maxX)/2;
  camY = (b.minY+b.maxY)/2;
}
function zoom(f) { camScale = Math.max(0.02, Math.min(camScale*f, 30)); }
function resetFilters() {
  activeFilters = { spacemix:new Set(), blocktype:new Set() };
  document.querySelectorAll('.filter-chip').forEach(c=>c.classList.remove('active'));
  fitView();
}

function isFiltered(z) {
  const { spacemix, blocktype } = activeFilters;
  if (spacemix.size && !spacemix.has(z.spacemix||'Unknown')) return false;
  if (blocktype.size && !blocktype.has(z.block_type||'Unknown')) return false;
  return true;
}
function toggleFilter(type, val, el) {
  const s = activeFilters[type];
  s.has(val)?s.delete(val):s.add(val);
  el.classList.toggle('active', s.has(val));
}

function renderLoop() {
  if (!appData) { requestAnimationFrame(renderLoop); return; }
  const W=canvas.width, H=canvas.height;
  ctx.clearRect(0,0,W,H);

  // Background
  ctx.fillStyle = '#f8f6f0';
  ctx.fillRect(0,0,W,H);

  // Grid (subtle)
  if (camScale > 0.04) {
    ctx.strokeStyle = 'rgba(0,0,0,0.05)';
    ctx.lineWidth = 0.5;
    const gridSize = 5000;
    const b = appData.floorBounds;
    for (let x = Math.floor(b.minX/gridSize)*gridSize; x < b.maxX+gridSize; x+=gridSize) {
      const [sx] = worldToScreen(x, 0);
      ctx.beginPath(); ctx.moveTo(sx,0); ctx.lineTo(sx,H); ctx.stroke();
    }
    for (let y = Math.floor(b.minY/gridSize)*gridSize; y < b.maxY+gridSize; y+=gridSize) {
      const [,sy] = worldToScreen(0, y);
      ctx.beginPath(); ctx.moveTo(0,sy); ctx.lineTo(W,sy); ctx.stroke();
    }
  }

  // Walls
  ctx.strokeStyle = 'rgba(30,30,40,0.35)';
  ctx.lineWidth = Math.max(0.5, camScale*0.012);
  for (const w of appData.walls) {
    const [x1,y1]=worldToScreen(w.x1,w.y1); const [x2,y2]=worldToScreen(w.x2,w.y2);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }

  // Zones ‚Äî colored by current mode
  const showStep = currentStep;
  for (const zone of appData.zones) {
    if (!isFiltered(zone)) continue;
    const pts = zone.points;
    if (!pts||pts.length<3) continue;

    const isHov = hoveredZone?.uid === zone.uid;
    const isPin = pinnedZone?.uid === zone.uid;
    const alpha = isHov||isPin ? 0.9 : 0.65;

    // Step 2: highlight split zone boundaries more visibly
    // Step 3: show sizing overlay
    // Step 4: show boundary boxes

    ctx.beginPath();
    pts.forEach((p,i) => {
      const [sx,sy] = worldToScreen(p.x,p.y);
      i===0 ? ctx.moveTo(sx,sy) : ctx.lineTo(sx,sy);
    });
    ctx.closePath();

    ctx.fillStyle = getZoneColor(zone, alpha);
    ctx.fill();

    // Border
    if (showStep >= 2 && zone.split_zone_id) {
      ctx.strokeStyle = isHov||isPin ? 'rgba(200,65,14,0.9)' : 'rgba(255,255,255,0.5)';
      ctx.lineWidth = isHov||isPin ? 2.5 : 1.5;
    } else {
      ctx.strokeStyle = isHov||isPin ? 'rgba(200,65,14,0.9)' : 'rgba(255,255,255,0.25)';
      ctx.lineWidth = isHov||isPin ? 2 : 0.5;
    }
    ctx.stroke();

    // Step 4: draw zone boundary box highlight
    if (showStep === 4) {
      const [bx1,by1]=worldToScreen(zone.bbox.minX,zone.bbox.minY);
      const [bx2,by2]=worldToScreen(zone.bbox.maxX,zone.bbox.maxY);
      ctx.strokeStyle = 'rgba(26,95,168,0.35)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4,3]);
      ctx.strokeRect(bx1,by1,bx2-bx1,by2-by1);
      ctx.setLineDash([]);
    }

    // Labels
    if (camScale > 0.06) {
      const [cx,cy] = worldToScreen(zone.centroid_x, zone.centroid_y);
      const bw = (zone.bbox.maxX-zone.bbox.minX)*camScale;
      if (bw > 50) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const fontSize = Math.min(10, bw*0.09);

        // Step 1: Show spacemix label
        // Step 2: Show split zone id
        // Step 3: Show size class + aspect ratio
        // Step 4: Show zone boundary label
        let mainLabel = '';
        let subLabel = '';

        if (showStep === 1) {
          mainLabel = zone.spacemix || zone.block_name;
          subLabel = zone.placement_cat || '';
        } else if (showStep === 2) {
          mainLabel = zone.split_zone_id || 'N/A';
          subLabel = zone.split_zone_label && zone.split_zone_label !== 'Unassigned'
            ? zone.split_zone_label.slice(0,16)
            : (zone.block_name||'').slice(0,16);
        } else if (showStep === 3) {
          mainLabel = zone.size_class || 'S';
          subLabel = zone.aspect_ratio ? zone.aspect_ratio.toFixed(1)+'‚à∂1' : '';
        } else if (showStep === 4) {
          mainLabel = zone.zone_boundary_label || zone.zone_category || '';
          subLabel = zone.spatial_area_m2 ? zone.spatial_area_m2.toFixed(0)+'m¬≤' : '';
        }

        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.font = `700 ${fontSize}px IBM Plex Mono`;
        ctx.fillText(mainLabel.length>18?mainLabel.slice(0,16)+'‚Ä¶':mainLabel, cx, cy-(subLabel?fontSize*0.55:0));

        if (subLabel && bw > 70) {
          ctx.fillStyle = 'rgba(255,255,255,0.7)';
          ctx.font = `400 ${Math.max(7,fontSize*0.8)}px IBM Plex Mono`;
          ctx.fillText(subLabel, cx, cy+fontSize*0.7);
        }
      }
    }

    // Step 3: Draw sizing annotation (X/Y arrows on hovered zone)
    if (showStep === 3 && (isHov || isPin) && zone.geom_width > 0) {
      const [bx1,by1]=worldToScreen(zone.bbox.minX,zone.bbox.minY);
      const [bx2,by2]=worldToScreen(zone.bbox.maxX,zone.bbox.maxY);
      ctx.strokeStyle='rgba(200,65,14,0.8)'; ctx.lineWidth=1.5;
      // X arrow
      ctx.beginPath(); ctx.moveTo(bx1,by2+10); ctx.lineTo(bx2,by2+10); ctx.stroke();
      // Y arrow
      ctx.beginPath(); ctx.moveTo(bx2+10,by1); ctx.lineTo(bx2+10,by2); ctx.stroke();
      // Dimension labels
      ctx.fillStyle='rgba(200,65,14,0.9)'; ctx.font='bold 9px IBM Plex Mono'; ctx.textAlign='center';
      ctx.fillText(`${(zone.geom_width/1000).toFixed(1)}m`, (bx1+bx2)/2, by2+20);
      ctx.textAlign='left';
      ctx.fillText(`${(zone.geom_height/1000).toFixed(1)}m`, bx2+14, (by1+by2)/2);
    }
  }

  // Room boundaries (dashed)
  ctx.strokeStyle = 'rgba(26,95,168,0.3)';
  ctx.setLineDash([3,3]);
  ctx.lineWidth = 0.8;
  for (const rb of appData.roomBoundaries) {
    const pts = rb.points;
    if (!pts||pts.length<3) continue;
    ctx.beginPath();
    pts.forEach((p,i) => {
      const [sx,sy]=worldToScreen(p.x,p.y);
      i===0?ctx.moveTo(sx,sy):ctx.lineTo(sx,sy);
    });
    ctx.closePath(); ctx.stroke();
    if (camScale > 0.05) {
      const [cx,cy]=worldToScreen(rb.centroid_x,rb.centroid_y);
      ctx.fillStyle='rgba(30,58,138,0.55)'; ctx.font='8px IBM Plex Mono'; ctx.textAlign='center';
      ctx.fillText(rb.room_name,cx,cy);
    }
  }
  ctx.setLineDash([]);

  // Columns
  ctx.fillStyle = 'rgba(50,60,90,0.55)';
  for (const col of appData.columns) {
    if (!col.points?.length) continue;
    ctx.beginPath();
    col.points.forEach((p,i)=>{const [sx,sy]=worldToScreen(p.x,p.y);i===0?ctx.moveTo(sx,sy):ctx.lineTo(sx,sy);});
    ctx.closePath(); ctx.fill();
  }

  // Step 2: draw superblock bounding boxes with labels
  if (showStep >= 2 && appData.superblockGroups) {
    const sbKeys = Object.keys(appData.superblockGroups).filter(k=>k!=='Unassigned');
    sbKeys.forEach((sb, idx) => {
      const group = appData.superblockGroups[sb].filter(z=>z.points?.length>0);
      if (!group.length) return;
      const allPts = group.flatMap(z=>z.points);
      const minX=Math.min(...allPts.map(p=>p.x)), maxX=Math.max(...allPts.map(p=>p.x));
      const minY=Math.min(...allPts.map(p=>p.y)), maxY=Math.max(...allPts.map(p=>p.y));
      const [bx1,by1]=worldToScreen(minX-200,minY-200);
      const [bx2,by2]=worldToScreen(maxX+200,maxY+200);
      const color = SUPERBLOCK_PALETTE[idx%SUPERBLOCK_PALETTE.length];
      ctx.strokeStyle = hexToRgba(color, 0.6);
      ctx.lineWidth = 2;
      ctx.setLineDash([6,4]);
      ctx.strokeRect(bx1,by1,bx2-bx1,by2-by1);
      ctx.setLineDash([]);

      // SB label
      if (camScale > 0.04) {
        const labelId = group[0].split_zone_id || `SB${idx+1}`;
        ctx.fillStyle = hexToRgba(color, 0.85);
        ctx.font = `bold 11px IBM Plex Mono`;
        ctx.textAlign = 'left';
        ctx.fillText(labelId, bx1+4, by1+14);
        // block count + area
        const totalArea = group.reduce((s,z)=>s+(z.spatial_area_m2||0),0);
        ctx.font = `9px IBM Plex Mono`;
        ctx.fillStyle = hexToRgba(color, 0.7);
        ctx.fillText(`${group.length}blk / ${totalArea.toFixed(0)}m¬≤`, bx1+4, by1+25);
      }
    });
  }

  requestAnimationFrame(renderLoop);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MOUSE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function setupMouseEvents() {
  canvas.addEventListener('mousedown', e=>{ dragging=true; lastMX=e.clientX; lastMY=e.clientY; });
  canvas.addEventListener('mousemove', e=>{
    if (dragging) {
      camX -= (e.clientX-lastMX)/camScale; camY -= (e.clientY-lastMY)/camScale;
      lastMX=e.clientX; lastMY=e.clientY; hoveredZone=null; hideTooltip();
    } else hitTest(e);
  });
  canvas.addEventListener('mouseup', ()=>{ dragging=false; });
  canvas.addEventListener('click', e=>{
    if (hoveredZone) { pinnedZone = pinnedZone?.uid===hoveredZone.uid ? null : hoveredZone; if (pinnedZone) showZonePanel(pinnedZone); else clearPanel(); }
  });
  canvas.addEventListener('wheel', e=>{
    e.preventDefault();
    const f = e.deltaY>0?0.88:1.12;
    const rect=canvas.getBoundingClientRect(), mx=e.clientX-rect.left, my=e.clientY-rect.top;
    const wx=(mx-canvas.width/2)/camScale+camX, wy=(my-canvas.height/2)/camScale+camY;
    camScale=Math.max(0.02,Math.min(camScale*f,30));
    camX=wx-(mx-canvas.width/2)/camScale; camY=wy-(my-canvas.height/2)/camScale;
  },{passive:false});
  canvas.addEventListener('mouseleave',()=>{ dragging=false; if (!pinnedZone){hoveredZone=null;hideTooltip();} });
}

function screenToWorld(sx,sy) { return [(sx-canvas.width/2)/camScale+camX, (sy-canvas.height/2)/camScale+camY]; }

function pointInPolygon(px,py,pts) {
  let inside=false;
  for (let i=0,j=pts.length-1;i<pts.length;j=i++) {
    const xi=pts[i].x,yi=pts[i].y,xj=pts[j].x,yj=pts[j].y;
    if ((yi>py)!==(yj>py)&&px<(xj-xi)*(py-yi)/(yj-yi)+xi) inside=!inside;
  }
  return inside;
}

function hitTest(e) {
  const rect=canvas.getBoundingClientRect();
  const sx=e.clientX-rect.left, sy=e.clientY-rect.top;
  const [wx,wy]=screenToWorld(sx,sy);
  let found=null;
  for (const zone of [...appData.zones].reverse()) {
    if (!isFiltered(zone)||!zone.points?.length) continue;
    const b=zone.bbox;
    if (wx<b.minX||wx>b.maxX||wy<b.minY||wy>b.maxY) continue;
    if (pointInPolygon(wx,wy,zone.points)){found=zone;break;}
  }
  if (found!==hoveredZone) {
    hoveredZone=found;
    if (found&&!pinnedZone){showTooltip(found,e); updatePanelHover(found);}
    else if (!found) hideTooltip();
  } else if (found) updateTooltipPos(e);
}

function showTooltip(zone,e) {
  document.getElementById('tt-name').textContent = zone.spatial_name||zone.block_name;
  document.getElementById('tt-1').innerHTML = `<strong>Block:</strong> ${zone.block_name}`;
  document.getElementById('tt-2').innerHTML = `<strong>SpaceMix:</strong> ${zone.spacemix||'‚Äî'} ¬∑ <strong>Cat:</strong> ${zone.placement_cat||'‚Äî'}`;
  document.getElementById('tt-3').innerHTML = `<strong>SB:</strong> ${zone.split_zone_id||'‚Äî'} ¬∑ <strong>Fit:</strong> ${((zone.geom_fit_score||0)*100).toFixed(0)}%`;
  updateTooltipPos(e);
  document.getElementById('tooltip').classList.add('visible');
}
function updateTooltipPos(e) {
  const tt=document.getElementById('tooltip');
  const x=e.clientX+16,y=e.clientY-10;
  tt.style.left=(x+230>window.innerWidth?x-250:x)+'px'; tt.style.top=y+'px';
}
function hideTooltip() { document.getElementById('tooltip').classList.remove('visible'); }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  PANEL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function updatePanelHover(zone) { if (!pinnedZone) showZonePanel(zone); }
function clearPanel() {
  document.getElementById('panel-empty').style.display='flex';
  document.getElementById('panel-content').style.display='none';
}
function showZonePanel(zone) {
  document.getElementById('panel-empty').style.display='none';
  const pc = document.getElementById('panel-content');
  pc.style.display='block';

  const sm = zone.spacemix||'Unknown';
  const tagClass = `tag-${sm.split('/')[0].trim()}`;
  const bf = zone.building_features||{};
  const bfFeatures = [['AHU','AHU'],['Window','Window/Glazing'],['Main_Entry','Main Entry'],['Core','Core'],['Toilets','Toilets'],['Fire_Egress','Fire Egress']];
  const bfHtml = bfFeatures.map(([k,l]) => {
    const v = bf[k]??0;
    if (v===-1) return `<div class="adj-row"><div class="adj-lbl"><span>${l}</span><span style="color:#ef4444;font-weight:700">‚äò FORBIDDEN</span></div></div>`;
    const pct = Math.max(0,Math.min(100,Math.abs(v)*100));
    const col = v>=0.5?'#10b981':v>0?'#f59e0b':'#d1d5db';
    return `<div class="adj-row"><div class="adj-lbl"><span>${l}</span><span style="color:${col}">${v.toFixed(2)}</span></div><div class="adj-bar"><div class="adj-fill" style="width:${pct}%;background:${col}"></div></div></div>`;
  }).join('');

  const btbMin = zone.btb_min||{};
  const topBtb = Object.entries(btbMin).filter(([,v])=>v&&v!==0).sort(([,a],[,b])=>Math.abs(b)-Math.abs(a)).slice(0,5);
  const btbHtml = topBtb.map(([n,v]) => {
    const pct=Math.max(0,Math.min(100,Math.abs(v)*100)); const col=v<0?'#ef4444':v>0?'#3b82f6':'#d1d5db';
    return `<div class="adj-row"><div class="adj-lbl"><span style="font-size:9px">${n.slice(0,22)}</span><span style="color:${col}">${v.toFixed(2)}</span></div><div class="adj-bar"><div class="adj-fill" style="width:${pct}%;background:${col}"></div></div></div>`;
  }).join('') || '<div style="font-size:10px;color:var(--ink2)">No B2B data</div>';

  pc.innerHTML = `
    <div class="info-block">
      <h5>Spatial Zone</h5>
      <div class="info-row"><span class="info-lbl">Name</span><span class="info-val">${zone.spatial_name||'‚Äî'}</span></div>
      <div class="info-row"><span class="info-lbl">Area</span><span class="info-val">${zone.spatial_area_m2?.toFixed(1)||'‚Äî'} m¬≤</span></div>
      <div class="info-row"><span class="info-lbl">Layer</span><span class="info-val">${zone.layer||'‚Äî'}</span></div>
      <div class="info-row"><span class="info-lbl">Match</span><span class="info-val" style="color:${zone.match_score>0.7?'#10b981':zone.match_score>0.4?'#f59e0b':'#ef4444'}">${((zone.match_score||0)*100).toFixed(0)}%</span></div>
    </div>
    <div class="info-block">
      <h5>Block Assignment</h5>
      <div class="info-row"><span class="info-lbl">Block</span><span class="info-val">${zone.block_name}</span></div>
      <div class="info-row"><span class="info-lbl">ID</span><span class="info-val">${zone.block_id||'‚Äî'}</span></div>
      <div class="info-row"><span class="info-lbl">SpaceMix</span><span><span class="tag ${tagClass}">${sm}</span></span></div>
      <div class="info-row"><span class="info-lbl">Type</span><span class="info-val">${zone.block_type||'‚Äî'}</span></div>
      <div class="info-row"><span class="info-lbl">Open/Closed</span><span class="info-val">${zone.open_closed||'‚Äî'}</span></div>
      <div class="info-row"><span class="info-lbl">Capacity</span><span class="info-val">${zone.block_capacity||'‚Äî'}</span></div>
    </div>
    <div class="info-block">
      <h5>Step 1 ‚Äî Position Score</h5>
      <div class="info-row"><span class="info-lbl">Placement Cat.</span><span class="info-val">${zone.placement_cat||'‚Äî'}</span></div>
      <div class="info-row"><span class="info-lbl">Position Score</span><span class="info-val">${(zone.position_score||0).toFixed(2)}</span></div>
      <div class="info-row"><span class="info-lbl">Dist to Core</span><span class="info-val">${((zone.dist_to_center||0)*100).toFixed(0)}%</span></div>
      <div class="info-row"><span class="info-lbl">Dist to Edge</span><span class="info-val">${((zone.dist_to_periphery||0)*100).toFixed(0)}%</span></div>
    </div>
    <div class="info-block">
      <h5>Step 2 ‚Äî Zone Splitting</h5>
      <div class="info-row"><span class="info-lbl">Split Zone ID</span><span class="info-val">${zone.split_zone_id||'N/A'}</span></div>
      <div class="info-row"><span class="info-lbl">Superblock</span><span class="info-val">${zone.superblock||'Unassigned'}</span></div>
      <div class="info-row"><span class="info-lbl">Block Count</span><span class="info-val">${zone.split_block_count||'‚Äî'}</span></div>
      <div class="info-row"><span class="info-lbl">Zone Area</span><span class="info-val">${zone.split_area?.toFixed(0)||'‚Äî'} m¬≤</span></div>
    </div>
    <div class="info-block">
      <h5>Step 3 ‚Äî Geometric Sizing</h5>
      <div class="info-row"><span class="info-lbl">Size Class</span><span class="info-val">${zone.size_class||'S'} (${zone.size_class==='L'?'Luxury':zone.size_class==='M'?'Comfort':'Function'})</span></div>
      <div class="info-row"><span class="info-lbl">Aspect Ratio</span><span class="info-val">${zone.aspect_ratio?.toFixed(2)||'‚Äî'} ‚à∂ 1</span></div>
      <div class="info-row"><span class="info-lbl">Width</span><span class="info-val">${((zone.geom_width||0)/1000).toFixed(1)} m</span></div>
      <div class="info-row"><span class="info-lbl">Height</span><span class="info-val">${((zone.geom_height||0)/1000).toFixed(1)} m</span></div>
      <div class="info-row"><span class="info-lbl">Geom. Fit</span><span class="info-val" style="color:${(zone.geom_fit_score||0)>0.7?'#10b981':(zone.geom_fit_score||0)>0.5?'#f59e0b':'#ef4444'}">${((zone.geom_fit_score||0)*100).toFixed(0)}%</span></div>
    </div>
    <div class="info-block">
      <h5>Step 4 ‚Äî Zone Boundary</h5>
      <div class="info-row"><span class="info-lbl">Zone Label</span><span class="info-val">${zone.zone_boundary_label||'‚Äî'}</span></div>
      <div class="info-row"><span class="info-lbl">Department</span><span class="info-val">${zone.department||'‚Äî'}</span></div>
    </div>
    <div class="info-block">
      <h5>Building Feature Adjacency</h5>
      ${bfHtml}
    </div>
    <div class="info-block">
      <h5>Block-to-Block Adjacency (Min)</h5>
      ${btbHtml}
    </div>
  `;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  HEADER & ANALYSIS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function updateHeaderStats() {
  const a = appData.analysis;
  document.getElementById('header-stats').style.display = 'flex';
  document.getElementById('floor-badge').textContent = `FLOOR PLAN ¬∑ ${a.total} ZONES`;
  document.getElementById('hs-zones').textContent = a.total;
  document.getElementById('hs-blocks').textContent = a.matched;
  document.getElementById('hs-sb').textContent = Object.keys(a.superblocks).filter(s=>s!=='Unassigned').length;
  document.getElementById('hs-area').textContent = a.totalArea + ' m¬≤';
  document.getElementById('s-total').textContent = a.total;
  document.getElementById('s-matched').textContent = a.matched;
  document.getElementById('s-sb').textContent = Object.keys(a.superblocks).filter(s=>s!=='Unassigned').length;
  document.getElementById('s-area').textContent = a.totalArea;
}

function buildAnalysisPanel() {
  const a = appData.analysis;
  const zc = a.zoneCategories||{};
  const maxCnt = Math.max(...Object.values(zc).map(v=>v.blockCount), 1);
  const catColors = PLACEMENT_COLORS;

  const catHtml = Object.entries(zc).sort((a,b)=>b[1].blockCount-a[1].blockCount).map(([cat,data])=>`
    <div class="bar-row">
      <div class="bar-lbl" style="color:${catColors[cat]||'#666'}">${cat.replace(' Zone','').slice(0,14)}</div>
      <div class="bar-track"><div class="bar-fill" style="width:${(data.blockCount/maxCnt*100).toFixed(0)}%;background:${catColors[cat]||'#9ca3af'}"></div></div>
      <div class="bar-val">${data.blockCount}</div>
    </div>`).join('');

  const sm = a.spacemix;
  const maxSM = Math.max(...Object.values(sm),1);
  const smHtml = Object.entries(sm).sort((a,b)=>b[1]-a[1]).map(([k,v])=>`
    <div class="bar-row">
      <div class="bar-lbl">${k}</div>
      <div class="bar-track"><div class="bar-fill" style="width:${(v/maxSM*100).toFixed(0)}%;background:${SPACEMIX_COLORS[k]||'#ccc'}"></div></div>
      <div class="bar-val">${v}</div>
    </div>`).join('');

  const prios = (appData.priorities||[]).slice(0,4);
  const prioHtml = prios.map(p=>`
    <div style="font-size:10px;padding:4px 0;border-bottom:1px solid var(--border);display:flex;gap:6px">
      <span style="color:var(--accent2);font-family:IBM Plex Mono;font-weight:600;flex-shrink:0">${p.priority.replace('Priority ','P')}</span>
      <span style="color:var(--ink2)">${p.rule.slice(0,50)}${p.rule.length>50?'‚Ä¶':''}</span>
    </div>`).join('');

  document.getElementById('analysis-block').innerHTML = `
    <h5>Zone Category Distribution</h5>
    ${catHtml}
    <h5 style="margin-top:10px">SpaceMix</h5>
    ${smHtml}
    ${prios.length ? `<h5 style="margin-top:10px">Priority Rules</h5>${prioHtml}` : ''}
  `;
}
</script>


</body></html>
